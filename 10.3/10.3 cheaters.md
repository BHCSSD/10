## 1. Movement & Control

### Smooth Sprite Movement (WASD / Arrows)

This method moves the sprite as long as a key is held down. It uses an **object** to keep all the sprite's "stats" in one neat container.

```javascript
let sprite = {
  cx: 200,    // Horizontal position
  cy: 200,    // Vertical position
  speed: 5,   // How many pixels to move per frame
  size: 50
};

function draw() {
  background(220);
  
  // keyIsDown checks if the key is currently pressed
  if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) { // 65 is 'A'
    sprite.cx -= sprite.speed; // Move Left (subtract from X)
  }
  if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) { // 68 is 'D'
    sprite.cx += sprite.speed; // Move Right (add to X)
  }
  if (keyIsDown(UP_ARROW) || keyIsDown(87)) { // 87 is 'W'
    sprite.cy -= sprite.speed; // Move Up (subtract from Y)
  }
  if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) { // 83 is 'S'
    sprite.cy += sprite.speed; // Move Down (add to Y)
  }
  
  rect(sprite.cx, sprite.cy, sprite.size, sprite.size);
}

```

### Jump Logic (Gravity)

To make a sprite jump, we don't just change its position; we change its **speed**. Gravity then constantly pulls that speed back down.

```javascript
let player = {
  cy: 350,
  speed: 0,      // Vertical velocity (movement speed)
  gravity: 0.8,  // The constant pull downward
  floor: 350     // The Y-coordinate where the ground is
}

function draw() {
  background(220);
  
  player.cy += player.speed;    // 1. Move the player by the current speed
  player.speed += player.gravity; // 2. Pull the speed down using gravity

  // Floor Collision: Stop the player if they hit the ground
  if (player.cy > player.floor) { 
    player.cy = player.floor;
    player.speed = 0;
  }
  
  ellipse(width/2, player.cy, 40, 40);
}

function keyPressed() {
  // Only jump if Space is pressed AND player is touching the floor
  if (key === ' ' && player.cy === player.floor) { 
    player.speed = -15; // A negative speed launches them UP
  }
}

```

---

## 2. Collision & Interaction

### Square Hitbox (The "Is Mouse Inside?" Check)

Use this for buttons or clicking on enemies. It checks if the mouse coordinates are between the left/right and top/bottom edges of a shape.

```javascript
// Place this inside draw() or mousePressed()
if (mouseX > x && mouseX < x + w && mouseY > y && mouseY < y + h) {
   // This code runs only if the mouse is inside the box!
}

```

### Circle Hitbox (Distance Check)

The easiest way to check if two circles (like a player and an enemy) are touching is to measure the **distance** between their centers.

```javascript
// Calculate distance between sprite and enemy
let d = dist(sprite.cx, sprite.cy, enemy.cx, enemy.cy);

// If distance is less than 30 pixels, they are touching!
if (d < 30) { 
  score -= 1;
  fill(255, 0, 0); // Turn red to show the hit
}

```

---

## 3. Game Systems

### Simple Timer (Countdown)

p5.js runs at roughly 60 frames per second. We use the `frameCount` to figure out when 1 second has passed.

```javascript
let timer = 30;

function draw() {
  // If the frameCount is divisible by 60, 1 second has passed
  if (frameCount % 60 === 0 && timer > 0) { 
    timer--; // Subtract 1 from the timer
  }
  
  text("Time Left: " + timer, 20, 20);
  
  if (timer === 0) {
    text("GAME OVER", width/2, height/2);
    noLoop(); // Stops the game
  }
}

```

### Random Spawning (The "Looping" Enemy)

When an enemy moves off the left side of the screen (`x < 0`), we teleport it back to the right side at a new random height.

```javascript
function draw() {
  enemy.cx -= enemy.speed; // Move enemy left

  if (enemy.cx < -50) {          // If fully off-screen...
    enemy.cx = width + 50;       // ...put it back on the right...
    enemy.cy = random(20, 380);  // ...at a random height!
  }
}

```

---

## 4. Troubleshooting

### The Console Debugger

If your game isn't working, use `print()`. It lets you "see" the invisible numbers inside your variables in the Console window below your code.

```javascript
// Use this to check why your player isn't moving
print("Player X: " + player.cx + " | Player Y: " + player.cy);

```
---
Here are three more essential "building blocks" for an intro game. These cover how to organize your game into screens, how to handle multiple items (like coins), and how to create a visual health bar.

---

## 4. Game States (The "Screen Switcher")

Most games aren't just one screen. You need a Start Screen, the Game, and a Game Over screen. We use a **variable** to keep track of which "state" the game is in.

```javascript
let gameState = "START"; // Options: "START", "PLAY", "GAMEOVER"

function draw() {
  background(220);

  if (gameState === "START") {
    showStartScreen();
  } else if (gameState === "PLAY") {
    playGame();
  } else if (gameState === "GAMEOVER") {
    showGameOver();
  }
}

function showStartScreen() {
  text("MY COOL GAME", 100, 100);
  text("Press ENTER to Start", 100, 150);
  if (keyIsPressed && keyCode === ENTER) {
    gameState = "PLAY";
  }
}

function playGame() {
  // All your movement and collision logic goes here!
  circle(mouseX, mouseY, 20); 
}

```

---

## 5. Collecting Items (Arrays & Loops)

If you want 10 coins, you don't want to make 10 separate variables. Instead, use an **Array** (a list). We use a `for` loop to draw every item in that list and check if the player touches them.

```javascript
let coins = []; // An empty list

function setup() {
  createCanvas(400, 400);
  // Fill the list with 5 random coin positions
  for (let i = 0; i < 5; i++) {
    coins.push({ x: random(width), y: random(height) });
  }
}

function draw() {
  background(220);

  for (let i = 0; i < coins.length; i++) {
    circle(coins[i].x, coins[i].y, 10); // Draw the coin

    // Check distance between player (mouseX) and this specific coin
    if (dist(mouseX, mouseY, coins[i].x, coins[i].y) < 15) {
      coins.splice(i, 1); // Remove 1 item from the list at index i
      score += 10;
    }
  }
}

```

---

## 6. The Visual Health Bar

Instead of just showing a number for health, you can use a rectangle. The trick is to make the **width** of the rectangle equal to your health variable.

```javascript
let health = 100;
let maxHealth = 100;

function draw() {
  background(220);

  // 1. Draw the "Background" of the bar (the empty slot)
  fill(50);
  rect(20, 20, 200, 20);

  // 2. Draw the "Fill" (the green part)
  // The width is the 'health' variable!
  fill(0, 255, 0);
  rect(20, 20, health * 2, 20); 

  // 3. Simple damage test
  if (mouseIsPressed) {
    health -= 1;
  }
  
  // Keep health from going below 0
  health = constrain(health, 0, maxHealth);
}

```

---

### Other tips

* **The `constrain()` Function:** Use `health = constrain(health, 0, 100)` to make sure your health never goes to -5 or 110. It "locks" a number between a min and a max.
* **Comments are Maps:** Use `//` to label your sections. In a 200-line game, finding your "Jump Logic" is much easier if you have a label.
* **Order Matters:** In the `draw()` loop, things drawn first are in the **back**. Things drawn last are in the **front**. Always draw your UI (score/health) last!

