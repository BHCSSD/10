## 1. Movement & Control

### Smooth Sprite Movement (WASD / Arrows)

This moves the sprite as long as a key is held down. We use an **object** to keep all the sprite's "stats" (variables) in one neat container.

```javascript
let sprite = {
  cx: 200,    // Horizontal position
  cy: 200,    // Vertical position
  speed: 5,   // How many pixels to move per frame
  size: 50
};

function draw() {
  background(220);
  
  // keyIsDown checks if the key is currently pressed
  if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) { // 65 is 'A'
    sprite.cx -= sprite.speed; // Move Left (subtract from X)
  }
  if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) { // 68 is 'D'
    sprite.cx += sprite.speed; // Move Right (add to X)
  }
  if (keyIsDown(UP_ARROW) || keyIsDown(87)) { // 87 is 'W'
    sprite.cy -= sprite.speed; // Move Up (subtract from Y)
  }
  if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) { // 83 is 'S'
    sprite.cy += sprite.speed; // Move Down (add to Y)
  }
  
  rect(sprite.cx, sprite.cy, sprite.size, sprite.size);
}

```

### Jump Logic (Gravity)

To make a sprite jump, we don't just change its position; we change its **speed**. Gravity then constantly pulls that speed back down.

```javascript
let player = {
  cy: 350,
  speed: 0,      // Vertical velocity (movement speed)
  gravity: 0.8,  // The constant pull downward
  floor: 350     // The Y-coordinate where the ground is
}

function draw() {
  background(220);
  
  player.cy += player.speed;    // 1. Move the player by the current speed
  player.speed += player.gravity; // 2. Pull the speed down using gravity

  // Floor Collision: Stop the player if they hit the ground
  if (player.cy > player.floor) { 
    player.cy = player.floor;
    player.speed = 0;
  }
  
  ellipse(width/2, player.cy, 40, 40);
}

function keyPressed() {
  // Only jump if Space is pressed AND player is touching the floor
  if (key === ' ' && player.cy === player.floor) { 
    player.speed = -15; // A negative speed launches them UP
  }
}

```

---

## 2. Collision & Interaction

### Square Hitbox (Clicking or Touching)

This uses the "Big Four" check: is the mouse (or another object) past the **Left** edge AND before the **Right** edge AND below the **Top** AND above the **Bottom**?

```javascript
// Example: Checking if the mouse is inside a square
if (mouseX > sprite.cx && mouseX < sprite.cx + sprite.size &&
    mouseY > sprite.cy && mouseY < sprite.cy + sprite.size) {
    
    if (mouseIsPressed) {
       // This code only runs if you click the square!
       sprite.size += 1; 
    }
}

```

### Circle Hitbox (Distance Check)

The easiest way to check if two circles are touching is to measure the **distance** between their centers using the `dist()` function.

```javascript
// dist(x1, y1, x2, y2)
let d = dist(sprite.cx, sprite.cy, enemy.cx, enemy.cy);

// If distance is less than the size of the sprites, they are touching!
if (d < 30) { 
  score -= 1;
  fill(255, 0, 0); // Turn red to show the hit
}

```

---

## 3. Screen Control (Game States)

Instead of having one giant block of code, we use a **variable** to switch between different "screens" like the Start Menu and the actual Game.

```javascript
let gameState = "START"; // Options: "START", "PLAY", "GAMEOVER"

function draw() {
  background(220);

  if (gameState === "START") {
    // --- START SCREEN CODE ---
    textSize(30);
    text("MY COOL GAME", 100, 200);
    text("Click to Start", 100, 250);

    if (mouseIsPressed) {
      gameState = "PLAY"; // Switch to the game
    }
  } 
  else if (gameState === "PLAY") {
    // --- ACTUAL GAME CODE ---
    circle(mouseX, mouseY, 20); 
    
    if (timer === 0) {
      gameState = "GAMEOVER"; // Switch to end screen
    }
  }
}

```

---

## 4. The `constrain()` Function

### Why use it?

`constrain()` is a "safety fence" for numbers. It forces a value to stay between a **minimum** and a **maximum**.

* **Stop Players at the edge:** Prevent them from walking off the screen.
* **Keep Health valid:** Ensure health doesn't go below 0 or above 100.

**Syntax:** `variable = constrain(value, min, max);`

### Example: The Screen Border

```javascript
// This keeps the sprite inside the canvas (between 0 and the width)
sprite.cx = constrain(sprite.cx, 0, width);
sprite.cy = constrain(sprite.cy, 0, height);

```

---

## 5. Game Systems

### Simple Timer (Countdown)

```javascript
let timer = 30;

function draw() {
  // frameCount % 60 is true roughly every 1 second
  if (frameCount % 60 === 0 && timer > 0) { 
    timer--; 
  }
  
  text("Time Left: " + timer, 20, 20);
}

```

### Random Spawning (The "Looping" Enemy)

```javascript
function draw() {
  enemy.x -= 5; // Move left

  if (enemy.x < -50) {          // If fully off-screen...
    enemy.x = width + 50;       // ...put it back on the right...
    enemy.y = random(20, 380);  // ...at a random height!
  }
}

```

### Visual Health Bar

```javascript
let health = 100;

function draw() {
  // 1. Draw the "Background" of the bar (the gray slot)
  fill(50);
  rect(20, 20, 200, 20);

  // 2. Draw the "Life" (the green part)
  // We use the health variable to set the width!
  fill(0, 255, 0);
  rect(20, 20, health * 2, 20); 

  // 3. Safety Check
  health = constrain(health, 0, 100);
}

```

---

## 6. Troubleshooting

### The Console Debugger

If your game isn't working, use `print()`. It lets you "see" the invisible numbers inside your variables in the Console window.

```javascript
// Put this in draw() to see your coordinates in real-time
print("X: " + sprite.cx + " | Y: " + sprite.cy);

```

### Order of Operations

In p5.js, the code runs from top to bottom.

* **First things drawn** are in the **background**.
* **Last things drawn** are in the **foreground** (front).
* **Always draw your UI (Score/Health) LAST** so it stays on top of the players and enemies

---
